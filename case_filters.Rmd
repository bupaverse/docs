---
title: Filter case
---

```{r echo = F, out.width="25%", fig.align = "right"}
knitr::include_graphics("images/icons/manipulate.PNG")

```

```{r}
library(bupaR)
```


# Case filters

## Activity presence

When looking at control-flow, we can select cases that contain a specific activity, for instance a X-Ray scan.

```{r}
patients %>%
	filter_activity_presence("X-Ray") %>%
	traces
```

Or that don't have a specific activity.

```{r}
patients %>%
	filter_activity_presence("X-Ray", reverse = T) %>%
	traces
```

We can also test more than one activity. In this case, we can require "all", "one_of" or "none" of them to be present, through setting the argument `method` correctly. 


For example, there are no cases that have both X-Ray and MRI-SCAN
```{r}
patients %>%
	filter_activity_presence(c("X-Ray", "MRI SCAN"), method = "all")  %>%
	traces
```

Almost all have on of them.

```{r}
patients %>%
	filter_activity_presence(c("X-Ray", "MRI SCAN"), method = "one_of")  %>%
	traces
```

And 3 have none of them. 

```{r}
patients %>%
	filter_activity_presence(c("X-Ray", "MRI SCAN"), method = "none")  %>%
	traces
```


## Case
## Case Condition
## Endpoints

Another way is to select cases with a specific start and or end activity. In case of the patients data set, all cases start with "Registration". Filtering cases that __don't__ start with Registration gives an empty log.

```{r}
patients %>%
	filter_endpoints(start_activities = "Registration", reverse = T)
```

If we are interested to see the "completed" cases, those that start with Registration and end we "Check-out", we can apply the following filter.

```{r fig.width = 9}
patients %>%
	filter_endpoints(start_activities = "Registration", end_activities = "Check-out") %>%
	process_map()
```

## Endpoints Condition
## Flow Time
## Idle Time
## Infrequent Flows
## Precedence

Another control-flow filtering approach is to look at precedences between activities. The `filter_precedence` function uses 5 different inputs

*	A list of (one or more) possible antecedent activities ("source"-activities)
*	A list of (one or more) possible consequent activities ("target"-activities)
*	A precedence_type
	*	directly_follows
	*	eventually_follows
*	A filter_method: all, one_of or none of the precedence rules should hold.
*	A reverse argument

If there is more than one antecedent or consequent activity, the filter will test __all__ possible pairs. The filter_method will tell the filter whether all of the rules should hold, at least one, or none are allowed.

For example, take the patients data. The following filter takes only cases where "Triage and Assessment" is directly followed by "Blood test".



```{r}
patients %>%
	filter_precedence(antecedents = "Triage and Assessment",
					  consequents = "Blood test",
					  precedence_type = "directly_follows") %>%
	traces
```

The following selects cases where Triage and Assessment is eventually followed by both Blood test and X-Ray, which never happens.

```{r}
patients %>%
	filter_precedence(antecedents = "Triage and Assessment",
					  consequents = c("Blood test", "X-Ray"),
					  precedence_type = "eventually_follows",
					  filter_method = "all") %>%
	traces
```

The next filter selects cases where Triage and Assessement is eventually followed by __at least one__ the three antecedents, by changing the filter method to _one_of_. 

```{r}
patients %>%
	filter_precedence(antecedents = "Triage and Assessment",
					  consequents = c("Blood test", "X-Ray", "MRI SCAN"),
					  precedence_type = "eventually_follows",
					  filter_method = "one_of") %>%
	traces
```

This final example only retains cases where Triage and Assessment is _not_ followed by any of the three consequent activities. The result is 2 incomplete cases where the last activity was Triage and Assessment. 

```{r}
patients %>%
	filter_precedence(antecedents = "Triage and Assessment",
					  consequents = c("Blood test", "X-Ray", "MRI SCAN"),
					  precedence_type = "eventually_follows",
					  filter_method = "none") %>%
	traces
```

## Precedence Condition
## Precedence Resource
## Processing time

Filtering on processing time happens in exactly the same way as the filter on throughput time, as the examples below show. 

```{r}
patients %>%
	filter_processing_time(interval = c(5, 100), units = "hours") %>%
	processing_time(units = "hours")
```

```{r}
patients %>%
	filter_processing_time(percentage = 0.5) %>%
	processing_time(units = "hours")
```

## Throughput time

Filtering on throughput time can be done in an absolute and relative way, just as for many other filters.

*	Absolute: specific a throughput time interval
*	Relative: specific a percentage target

For instance, we can filter cases with a throughput time between 50 and 100 hours. Notice that setting the time unit argument appropriately is important in this case.

```{r}
patients %>%
	filter_throughput_time(interval = c(50, 100), units = "hours") %>%
	throughput_time(units = "hours")
```

Alternatively, we can filter the 50% cases with the lowest throughput time.

```{r}
patients %>%
	filter_throughput_time(percentage = 0.5) %>%
	throughput_time(units = "hours")
```

In both cases, the selection can be negated using the `reverse` argument. When using an interval, one of the limits can be set to NA to create an open interval. 

## Time period
	
Filtering cases by time period can be done using the `filter_time_period` introduced above. There are four different methods that result in case filters:

*	start: all cases started in an interval
*	complete: all cases completed in an interval
*	contained: all cases contained in an interval
*	intersecting: all cases with some activity in an interval
	
The following four example dotted charts show the impact of the four different methods using the same interval. 

```{r}
sepsis %>%
	filter_time_period(interval = ymd(c(20150101, 20150131)), filter_method = "start") %>%
	dotted_chart
sepsis %>%
	filter_time_period(interval = ymd(c(20150101, 20150131)), filter_method = "complete") %>%
	dotted_chart
sepsis %>%
	filter_time_period(interval = ymd(c(20150101, 20150131)), filter_method = "contained") %>%
	dotted_chart
sepsis %>%
	filter_time_period(interval = ymd(c(20150101, 20150131)), filter_method = "intersecting") %>%
	dotted_chart
```

	
## Trace Frequency

Filtering on trace frequency is similar to the filters on activity/resource frequence and the performance filter: you can 
choose between a percentage target or between an frequency interval.

Select 80% of the cases that share the most common traces.

```{r}
sepsis %>%
	filter_trace_frequency(percentage = 0.8) %>%
	n_cases()
```

Or the 20% least common ones. 

```{r}
sepsis %>%
	filter_trace_frequency(percentage = 0.2) %>%
	n_cases()
```

Or the cases of which the trace frequency is less than 50.

```{r}
sepsis %>%
	filter_trace_frequency(interval = c(0,50)) %>%
	n_cases()
```

## Trace Length

Filtering on trace length is similar to filters on processing or throughput time. Only the units argument is not needed here. 

```{r}
patients %>%
	filter_trace_length(interval = c(2, 5)) %>%
	trace_length()
```

```{r}
patients %>%
	filter_trace_length(percentage = 0.5) %>%
	trace_length()
```


	
	
	
	
	